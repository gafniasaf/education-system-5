import { NextRequest, NextResponse } from 'next/server';
import { withRouteTiming } from '@/server/withRouteTiming';
import { isTestMode } from '@/lib/testMode';
import { __TEST_LOGS__ } from '@/lib/logger';

function isAdminDiag(req: NextRequest) {
  const hdr = req.headers.get('x-admin-diag') || '';
  return hdr === '1' || hdr === 'true';
}

export const runtime = 'nodejs';
export const GET = withRouteTiming(async function GET(req: NextRequest) {
  const requestId = req.headers.get('x-request-id') || crypto.randomUUID();
  if (!isTestMode()) {
    return NextResponse.json({ error: { code: 'NOT_FOUND', message: 'Not found' }, requestId }, { status: 404, headers: { 'x-request-id': requestId } });
  }
  if (!isAdminDiag(req)) {
    return NextResponse.json({ error: { code: 'FORBIDDEN', message: 'missing x-admin-diag' }, requestId }, { status: 403, headers: { 'x-request-id': requestId } });
  }
  let n = 50;
  let level = 'error';
  let levels: string[] = [];
  let traceId = '';
  let sinceMs = 0;
  let offset = 0;
  try {
    const u = new URL(req.url);
    const nStr = u.searchParams.get('n');
    const lvl = u.searchParams.get('level');
    const lvls = u.searchParams.get('levels') || u.searchParams.get('include');
    traceId = (u.searchParams.get('traceId') || u.searchParams.get('requestId') || u.searchParams.get('trace') || '').trim();
    const sinceStr = u.searchParams.get('sinceMs') || u.searchParams.get('since');
    const offsetStr = u.searchParams.get('offset');
    if (nStr) {
      const num = Number(nStr);
      if (!Number.isNaN(num)) n = Math.max(1, Math.min(200, num));
    }
    if (lvl) level = String(lvl).toLowerCase();
    if (lvls) {
      levels = String(lvls)
        .split(',')
        .map(s => s.trim().toLowerCase())
        .filter(Boolean);
    }
    if (sinceStr) {
      const ms = Number(sinceStr);
      if (!Number.isNaN(ms) && ms > 0) sinceMs = ms;
    }
    if (offsetStr) {
      const off = Number(offsetStr);
      if (!Number.isNaN(off) && off >= 0) offset = off;
    }
  } catch {}
  const wantAll = (level === 'all') || levels.includes('all') || levels.length === 0 && level === '';
  const allowLevels = levels.length > 0 ? new Set(levels) : new Set([level]);
  const now = Date.now();
  const minTs = sinceMs > 0 ? now - sinceMs : 0;
  const filtered = Array.isArray(__TEST_LOGS__)
    ? __TEST_LOGS__.filter((e: any) => {
        const pth = String(e?.obj?.path || e?.obj?.req?.path || '');
        // Exclude entries generated by this diagnostics endpoint to keep pagination stable
        if (pth === '/api/diag/errors') return false;
        if (!wantAll && !allowLevels.has(String(e?.level || '').toLowerCase())) return false;
        if (minTs && typeof e?.ts === 'number' && e.ts < minTs) return false;
        if (traceId) {
          const rid = e?.obj?.requestId || e?.obj?.req?.requestId || '';
          if (String(rid) !== traceId) return false;
        }
        return true;
      })
    : [];
  const ordered = filtered.slice().reverse(); // newest first
  const start = Math.min(offset, Math.max(0, ordered.length));
  const end = Math.min(start + n, ordered.length);
  const pageSlice = ordered.slice(start, end);
  const wantStack = (() => { try { const u = new URL(req.url); return (u.searchParams.get('stack') || '') === '1'; } catch { return false; } })();
  const items = pageSlice.map((e: any) => ({
    level: e?.level || 'unknown',
    msg: e?.msg || '',
    ts: typeof e?.ts === 'number' ? e.ts : undefined,
    requestId: e?.obj?.requestId || e?.obj?.req?.requestId || undefined,
    path: e?.obj?.path || e?.obj?.req?.path || undefined,
    // Surface common error fields only; avoid leaking full objects
    err: e?.obj?.err || e?.obj?.error || undefined,
    errStack: wantStack ? (e?.obj?.stack || e?.obj?.err?.stack || undefined) : undefined
  }));
  const nextOffset = end < ordered.length ? end : null;
  const hasMore = nextOffset !== null;
  // Optional CSV
  try {
    const u = new URL(req.url);
    const fmt = (u.searchParams.get('format') || '').toLowerCase();
    if (fmt === 'csv') {
      const header = ['ts','level','requestId','path','msg'].join(',');
      const rows = items.map(i => [i.ts || '', i.level || '', i.requestId || '', i.path || '', (i.msg || '').replaceAll('"','""')].map(String).join(','));
      const csv = [header, ...rows].join('\n');
      return new Response(csv, { status: 200, headers: { 'content-type': 'text/csv; charset=utf-8', 'x-request-id': requestId } });
    }
  } catch {}
  return NextResponse.json({ requestId, items, page: { offset: start, limit: n, nextOffset, total: ordered.length, hasMore } }, { status: 200, headers: { 'x-request-id': requestId } });
});

export const POST = withRouteTiming(async function POST(req: NextRequest) {
  const requestId = req.headers.get('x-request-id') || crypto.randomUUID();
  if (!isTestMode()) {
    return NextResponse.json({ error: { code: 'NOT_FOUND', message: 'Not found' }, requestId }, { status: 404, headers: { 'x-request-id': requestId } });
  }
  if (!isAdminDiag(req)) {
    return NextResponse.json({ error: { code: 'FORBIDDEN', message: 'missing x-admin-diag' }, requestId }, { status: 403, headers: { 'x-request-id': requestId } });
  }
  try {
    const u = new URL(req.url);
    const clear = (u.searchParams.get('clear') || '') === '1';
    if (clear && Array.isArray(__TEST_LOGS__)) {
      __TEST_LOGS__.splice(0, __TEST_LOGS__.length);
      return NextResponse.json({ requestId, ok: true, cleared: true, size: 0 }, { status: 200, headers: { 'x-request-id': requestId } });
    }
  } catch {}
  return NextResponse.json({ requestId, ok: true }, { status: 200, headers: { 'x-request-id': requestId } });
});


